# -*- coding: utf-8 -*-
"""Markov_simulation_until_ContactMatrix.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LGWZx3ufYsxbdmKKlBS7wstAHmhTqUfH
"""

import copy
from itertools import combinations
import random as random
import EoN
import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import random
import math


# Defining Parameters

### STATE D ###

social_mixing_matrix = ""  # From csv
contact_duration = ""

### random seed ###
seed = 2020


# generate dictionary


def dict_generate(n_total):
    pdict = {}
    for i in range(n_total):
        pdict[i + 1] = {}

    return pdict


# Age distribution
def age_distribute(
    n_students,
    s_age_lower,
    s_age_upper,
    avg_batch_size,
    n_teach,
    t_age_lower,
    t_age_upper,
    n_nonteach,
    nt_age_lower,
    nt_age_upper,
    n_total,
    seed,
):
    random.seed(seed)

    pdict = dict_generate(n_total)

    category = ["Students", "Teaching", "Non teaching"]

    age_count = {"Students": {}, "Teaching": 0, "Non teaching": 0}

    batch = n_students // avg_batch_size

    limit = {"Students": {}, "Teaching": n_teach, "Non teaching": n_nonteach}

    limit["Students"]["Batch 1"] = avg_batch_size + n_students % avg_batch_size
    age_count["Students"]["Batch 1"] = 0

    for i in range(batch - 1):
        limit["Students"]["Batch " + str(i + 2)] = avg_batch_size
        age_count["Students"]["Batch " + str(i + 2)] = 0

    stu_age = list(range(s_age_lower, s_age_upper + 1))

    for i in pdict.keys():
        temp = []
        for cat in category:
            if cat == "Students":
                for key in age_count[cat].keys():
                    if age_count[cat][key] >= limit["Students"][key]:
                        temp.append(key)

            elif age_count[cat] >= limit[cat]:
                del category[category.index(cat)]

        for j in temp:
            del age_count["Students"][j]
            stu_age.remove(int(j[-1]) + 17)

        pick = random.choice(category)

        pdict[i]["categ"] = pick
        if pick == "Students":
            age = random.choice(stu_age)
            pdict[i]["Age"] = age
            age_count[pick]["Batch " + str(age - s_age_lower + 1)] += 1

        elif pick == "Teaching":
            age = random.randint(t_age_lower, t_age_upper)
            pdict[i]["Age"] = age
            age_count[pick] += 1

        elif pick == "Non teaching":
            age = random.randint(nt_age_lower, nt_age_upper)
            pdict[i]["Age"] = age
            age_count[pick] += 1

    return pdict


def infected(n_total):
    pdict = age_distribute(
        n_students,
        s_age_lower,
        s_age_upper,
        avg_batch_size,
        n_teach,
        t_age_lower,
        t_age_upper,
        n_nonteach,
        nt_age_lower,
        nt_age_upper,
        n_total,
        seed,
    )

    for k in pdict.keys():
        pdict[k]["Infected"] = 0

    rate = int(n_total*infection_prop)

    for i in random.sample(list(pdict.keys()), rate):
        pdict[i]["Infected"] = 1

    return pdict


def trunc_gauss(mean, sigma, lower, upper):
    a = random.gauss(mean, sigma)

    while (lower <= a <= upper) == False:
        a = random.gauss(mean, sigma)

    return int(a)


def infection_day():

    mean = 6
    sigma = 2
    lower = 1
    upper = 15

    pdict = infected(n_total)

    infect_list = []

    for k in pdict.keys():
        if pdict[k]["Infected"] == 1:
            infect_list.append(k)
            day = trunc_gauss(mean, sigma, lower, upper)

            pdict[k]["day of infection"] = day

            if 3 <= day <= 10:
                # Danger flags -s Super -a Medium -b Low
                pdict[k]["danger"] = "s"
            else:
                pdict[k]["danger"] = "a"

            # Status = 1 --> Symptomatic ; 0 --> Asymptomatic
            pdict[k]["Status"] = 0

        else:
            pdict[k]["day of infection"] = np.nan
            pdict[k]["danger"] = "b"
            pdict[k]["Status"] = np.nan
    return pdict, infect_list


def symptomatic(n_total):
    pdict, infect_list = infection_day()

    rate = 0.6  # 60% symptomatic, 40% asymptomatic

    for i in random.sample(infect_list, int(rate * len(infect_list))):
        pdict[i]["Status"] = 1

    return pdict, infect_list


def Diff(li1, li2):
    li_dif = [i for i in li1 + li2 if i not in li1 or i not in li2]
    return li_dif


def test_kit(kit_specificity, kit_sensitivity, fnr, fpr):

    print(kit_specificity)

    pdict, infect_list = symptomatic(n_total)

    for k in pdict.keys():
        pdict[k]["ContactMatrix"] = 0

    for i in random.sample(infect_list, int(fnr * len(infect_list))):
        pdict[i]["ContactMatrix"] = 1

    uninfect_list = Diff(list(pdict.keys()), infect_list)

    fpr_uninfected = random.sample(
        uninfect_list, int(fpr * len(uninfect_list)))

    remain_uninfect_list = Diff(uninfect_list, fpr_uninfected)

    for i in remain_uninfect_list:
        pdict[i]["ContactMatrix"] = 1

    return pdict


#pdict = test_kit(kit_specificity, kit_sensitivity, fnr, fpr)

#ptable = pd.DataFrame.from_dict(pdict).T

"""Defining libraries to be used"""


"""# Data pre-processing"""

Contact_school = pd.read_excel(
    "https://github.com/kzuri/school_reopening_model/blob/main/ContactMatricesPremetAl.xlsx?raw=true",
    sheet_name="School Contacts", engine='openpyxl'
)
Contact_res = pd.read_excel(
    "https://github.com/kzuri/school_reopening_model/blob/main/ContactMatricesPremetAl.xlsx?raw=true",
    sheet_name="Residential Contacts", engine='openpyxl'
)


def get_class_dictionary():
    global pdict
    pdict = test_kit(kit_specificity, kit_sensitivity, fnr, fpr)
    global ptable
    ptable = pd.DataFrame.from_dict(pdict).T
    ptable = ptable[ptable["ContactMatrix"] == 1]
    pdict = ptable.T.to_dict()

    return pdict

# Underlying contact network- will make edges on random with 6 different people
# depend on their age and average number of contacts they have from PremetAl Matrix


def getUserLists(UserType):
    UserList = ptable[ptable["categ"] == UserType].index.to_list()
    return UserList


# Each student interacts with (5-10) other students, Student <-> non teaching (3-4)
# Teacher to Teacher (3) , Student <-> Teacher = 3-4 students for every teacher, Non-Taching <-> Non Teaching = (6),
# Teaching <-> Non Teaching = For every teacher 3-4 Non Teaching.

def get_categ_list():
    stud_list = getUserLists("Students")
    teach_list = getUserLists("Teaching")
    non_teach_list = getUserLists("Non teaching")
    stud_age = list(set(ptable[ptable["categ"] == "Students"]["Age"]))

    Student_num = len(stud_list)
    Teacher_num = len(teach_list)
    Non_teach_num = len(non_teach_list)

    return stud_age, stud_list, teach_list, non_teach_list


"""# Conditions for edge formation"""


# for every member in list1 there will be "multiplier" number of edges in list 2
def create_edges(list1, list2, multiplier):
    edges = []

    total_interactions = multiplier * len(list1)
    while total_interactions > 0:
        node1 = random.choice(list1)
        node2 = random.choice(list2)
        if node1 != node2:
            edges.append((node1, node2))
            total_interactions = total_interactions - 1

    return edges


def divide_age_grp(pdict, stud_age, stud_list):
    age_grp = {}

    for i in stud_age:
        age_grp[i] = []

    for i in stud_list:
        age_grp[pdict[i]["Age"]].append(i)

    return age_grp


def get_index_combination(combination, source_list):
    # combination_list = list(combination)
    a, b = zip(*combination)
    a = list(a)
    sl = set(a)
    return [a.index(i) for i in sl]


def intraclass_generate(ncluster, prob_interaction=0):
    connection_grp = {}
    connection = []
    stud_age, stud_list, teach_list, non_teach_list = get_categ_list()
    age_grp = divide_age_grp(pdict, stud_age, stud_list)

    for k in age_grp.keys():
        combination = combinations(age_grp[k], 2)
        combination1 = copy.copy(combination)

        idx_list = get_index_combination(combination, age_grp[k])
        combination_list = list(combination1)

        for i, idx in enumerate(idx_list[:-1]):
            if idx_list[i + 1] - idx_list[i] < ncluster + 1:
                connection += combination_list[idx_list[i]: idx_list[i + 1]]
            else:
                for j in random.sample(
                    combination_list[idx_list[i]: idx_list[i + 1]],
                    random.randint(ncluster - 1, ncluster + 1),
                ):
                    connection.append(j)

    return connection


def interclass_generate():
    connection_list = []
    stud_age, stud_list, teach_list, non_teach_list = get_categ_list()
    age_grp = divide_age_grp(pdict, stud_age, stud_list)
    combination = combinations(age_grp.keys(), 2)
    for i in combination:
        connection_list += create_edges(age_grp[i[0]], age_grp[i[1]], 1)

    return connection_list


"""Combining result from above helper functions"""


def edge_list_gen(stud_list, teach_list, non_teach_list):
    edges_list = []
    edges_list += create_edges(teach_list, teach_list, 3)
    edges_list += create_edges(non_teach_list, non_teach_list, 6)
    edges_list += create_edges(teach_list, non_teach_list, 3)
    # For every teacher 3 students
    edges_list += create_edges(teach_list, stud_list, 3)
    edges_list += create_edges(stud_list, non_teach_list, 3)

    # Age wise students to be added into classes & their interactions to be appended
    edges_list += intraclass_generate(ncluster=5)
    edges_list += interclass_generate()
    edges_list = list(set(edges_list))

    return edges_list


"""# Initializing  `Contacts` network"""

categ_contact_matrix = [[10.0, 6.0, 0.8],  # s-s s-t s-nt
                        [6.0, 8.0, 2.0],  # t-s t-t t-nt
                        [0.8, 2.0, 4.0]]  # nt-s nt-t nt-nt

age_contact_matrix = Contact_school.to_numpy()


def add_nodes(pdict):
    node = []

    for k in pdict.keys():
        node.append((k, {"categ": pdict[k]["categ"],
                         "Age": pdict[k]["Age"],
                         "Infected": pdict[k]["Infected"],
                         "DayOfInfection": pdict[k]["day of infection"],
                         "Status": pdict[k]["Status"],
                         "risk_coeff": pdict[k]["danger"]},))

    return node


def edge_weights(contact_matrix_categ, contact_matrix_age, pdict, edge, mode):  # According to category
    i = edge[0]
    j = edge[1]

    categ_index = {"Students": 0, "Teaching": 1, "Non teaching": 2}

    if mode == "category":
        return contact_matrix_categ[categ_index[pdict[i]["categ"]]][categ_index[pdict[i]["categ"]]]
    elif mode == "age":
        return contact_matrix_age[pdict[i]["Age"] // 8][pdict[j]["Age"] // 8]
    else:
        raise NameError(mode)


def edge_weights_premetal(contact_matrix, pdict, edge):  # According to age
    i = edge[0]
    j = edge[1]
    return contact_matrix[pdict[i]["Age"] // 8][pdict[j]["Age"] // 8]


def network_gen(pdict):
    Contacts = nx.Graph()
    stud_age, stud_list, teach_list, non_teach_list = get_categ_list()
    edges_list = edge_list_gen(stud_list, teach_list, non_teach_list)

    Node_info = add_nodes(pdict)
    Contacts.add_nodes_from(Node_info)

    # Contacts graph will basically consist of the edge weight which would be the number of connects a node can make according to the age and also whether or not it is infected
    Contacts.add_edges_from(edges_list)

    # transmission_weight will come from contact_matrix and hence we wont need above weights but this will depend on age

    edge_attribute_dict = {edge: edge_weights(categ_contact_matrix,
                                              age_contact_matrix,
                                              pdict,
                                              edge,
                                              mode="age")  # mode : age,category
                           for edge in Contacts.edges()}

    nx.set_edge_attributes(
        Contacts, values=edge_attribute_dict, name="transmission_weight")

    return Contacts


"""# EoN function"""


def contagion_model():
    pdict = get_class_dictionary()
    stud_age, stud_list, teach_list, non_teach_list = get_categ_list()
    Contacts = network_gen(pdict)

    # Graph which is not induced, for example: E -> I, I -> R
    H = nx.DiGraph()
    H.add_node('S')  # Susceptible
    # we can also have a weight label to add higher chances of people moving from E->I depending on duration- not needed now, need this rate, could be constant, need lit
    H.add_edge('E', 'I', rate=0.29)
    H.add_edge('I', 'R', rate=0.95)  # need recovery rate for India/TN

    # Induced Graph according to transmission rates or probability of transitions
    J = nx.DiGraph()
    for nodes in Contacts.nodes():
        if Contacts.nodes[nodes]["Status"] == "Asymptomatic":
            J.add_edge(('I', 'S'), ('I', 'E'), rate=0.225,
                       weight_label='transmission_weight')
        else:
            # Input - Transmission rate (beta)
            J.add_edge(('I', 'S'), ('I', 'E'), rate=0.9,
                       weight_label='transmission_weight')

    IC = {}  # initial status
    for nodes in Contacts.nodes():
        if Contacts.nodes[nodes]["Infected"] == 1:
            IC[nodes] = 'I'
        else:
            IC[nodes] = 'S'

    return_statuses = ('S', 'E', 'I', 'R')

    # sim=EoN.Gillespie_SIR(Contacts,1,1,return_full_data=True)
    t, S, E, I, R = EoN.Gillespie_simple_contagion(Contacts,  # t, S, E, I, R - these 5 lists goes into plotting our final graph
                                                   H, J, IC,
                                                   return_statuses,
                                                   tmax=float('Inf'))

    return t, S, E, I, R


def generateOutput(
    p_n_students,
    p_n_teach,
    p_n_nonteach,
    p_s_age_lower,
    p_s_age_upper,
    p_avg_batch_size,
    p_t_age_lower,
    p_t_age_upper,
    p_nt_age_lower,
    p_nt_age_upper,
    p_infection_prop,
    p_kit_sensitivity,
    p_kit_specificity
):

    global n_students
    global n_teach
    global n_nonteach

    global n_total

    global student_prop
    global teach_prop
    global nonteach_prop

    global s_age_lower
    global s_age_upper

    global avg_batch_size

    global t_age_lower
    global t_age_upper

    global nt_age_lower
    global nt_age_upper

    global outside_prop
    global inside_prop

    global quarantine_prop
    global quarantine_size
    global batches
    global daily_outside_pop

    global infection_prop
    global testing_period
    global testing_positive_prop

    global kit_sensitivity
    global kit_specificity

    global fnr
    global fpr

    n_students = p_n_students
    n_teach = p_n_teach
    n_nonteach = p_n_nonteach

    n_total = n_students + n_teach + n_nonteach

    student_prop = n_students / n_total
    teach_prop = n_teach / n_total
    nonteach_prop = n_nonteach / n_total

    s_age_lower = p_s_age_lower
    s_age_upper = p_s_age_upper

    avg_batch_size = p_avg_batch_size

    t_age_lower = p_t_age_lower
    t_age_upper = p_t_age_upper

    nt_age_lower = p_nt_age_lower
    nt_age_upper = p_nt_age_upper

    # residential campus
    outside_prop = 0  # changes according to groups
    inside_prop = 1 - outside_prop

    ### STATE B ###
    quarantine_prop = 0.1
    quarantine_size = (n_students + n_teach + n_nonteach) * quarantine_prop
    batches = 100  # total (students+teacher+...)
    daily_outside_pop = 0  # Pending...

    # 5% infected --india mean i.e 65/1300 infected
    infection_prop = p_infection_prop
    testing_period = 14  # function of batches
    testing_positive_prop = ""  # function of sensitivity and specificity
    # probability of testing if symptoms arises

    kit_sensitivity = p_kit_sensitivity
    kit_specificity = p_kit_specificity

    fnr = 1 - kit_sensitivity
    fpr = 1 - kit_specificity

    final_t, final_S, final_E, final_I, final_R = contagion_model()

    print("")
    print("")
    print(final_t)
    print(final_S)
    print(final_E)
    print(final_I)
    print(final_R)

    return final_t, final_S, final_E, final_I, final_R


'''
t, S, E, I, R = contagion_model()

import matplotlib.pyplot as plt
plt.semilogy(t, S, label = 'Susceptible')
plt.semilogy(t, E, label = 'Exposed')
plt.semilogy(t, I, label = 'Infected')
plt.semilogy(t, R, label = 'Recovered')
plt.legend()
#sim.display(time=1)
plt.show()
'''
